<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI éš”ç©ºæ‰‹åŠ¿ç»˜å›¾ç³»ç»Ÿ</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; }
        
        /* è§†é¢‘å±‚ï¼šæ°´å¹³ç¿»è½¬ä»¥è·å¾—é•œå­æ•ˆæœï¼Œè®¾ä¸ºä¸å¯è§æˆ–åº•å±‚ï¼Œä¸»è¦ç”¨äºè®¡ç®— */
        #input_video { display: none; transform: scaleX(-1); }
        
        /* ç”»å¸ƒå±‚ï¼šå…¨å± */
        #output_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
            display: none; /* é»˜è®¤éšè— */
            flex-direction: column;
            gap: 15px;
            text-align: center;
        }
        
        #ui-panel.active { display: flex; animation: fadeIn 0.3s ease; }
        
        h2 { margin: 0 0 10px 0; color: #333; }
        
        .control-group { display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        
        .btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            position: relative;
        }
        
        .btn.selected { border-color: #007bff; background: #e7f1ff; color: #007bff; transform: scale(1.05); }
        .btn.hovered { background: #ffe082; transform: scale(1.1); } /* æ‚¬åœæ•ˆæœ */

        .color-btn { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #ddd; padding: 0; }
        .color-btn.selected { transform: scale(1.2); border-color: #333; }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-bar {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            z-index: 5;
            pointer-events: none;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }
    </style>
</head>
<body>

    <video id="input_video"></video>
    
    <canvas id="output_canvas"></canvas>

    <div id="status-bar">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>

    <div id="ui-panel">
        <h2>ğŸ› ï¸ å·¥å…·ç®±</h2>
        
        <div>å·¥å…·</div>
        <div class="control-group">
            <div class="btn selected" id="tool-pen" data-type="tool" data-val="pen">ğŸ–Šï¸ ç¬”</div>
            <div class="btn" id="tool-eraser" data-type="tool" data-val="eraser">ğŸ§½ æ©¡çš®</div>
        </div>

        <div>é¢œè‰²</div>
        <div class="control-group">
            <div class="btn color-btn selected" style="background: #ff0000;" data-type="color" data-val="#ff0000"></div>
            <div class="btn color-btn" style="background: #00ff00;" data-type="color" data-val="#00ff00"></div>
            <div class="btn color-btn" style="background: #0000ff;" data-type="color" data-val="#0000ff"></div>
            <div class="btn color-btn" style="background: #ffff00;" data-type="color" data-val="#ffff00"></div>
            <div class="btn color-btn" style="background: #ffffff;" data-type="color" data-val="#ffffff"></div>
        </div>

        <div>ç¬”åˆ·å¤§å°</div>
        <div class="control-group">
            <div class="btn" data-type="size" data-val="5">å°</div>
            <div class="btn selected" data-type="size" data-val="10">ä¸­</div>
            <div class="btn" data-type="size" data-val="20">å¤§</div>
        </div>
    </div>

<script>
/**
 * æ ¸å¿ƒé€»è¾‘éƒ¨åˆ†
 */
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const uiPanel = document.getElementById('ui-panel');
const statusBar = document.getElementById('status-bar');

// ç»˜å›¾çŠ¶æ€
let drawingPaths = []; // å­˜å‚¨æ‰€æœ‰çš„ç¬”ç”» [[{x,y}, ...], ...]
let currentPath = [];
let particles = []; // é›ªèŠ±ç²’å­

// ç³»ç»Ÿé…ç½®
let config = {
    tool: 'pen', // pen, eraser
    color: '#ff0000',
    lineWidth: 10,
    isMenuOpen: false,
    width: window.innerWidth,
    height: window.innerHeight
};

// å…¨å±€å˜é‡
let lastMenuToggleTime = 0; // é˜²æŠ–
let lastZoomDist = null; // ç¼©æ”¾è®°å½•
let scaleFactor = 1; // å½“å‰ç¼©æ”¾å€ç‡
let panOffset = { x: 0, y: 0 }; // æ¼«æ¸¸åç§»ï¼ˆæš‚æœªå®Œå…¨å®ç°æ¼«æ¸¸ï¼Œä¸»è¦ç”¨äºç¼©æ”¾ä¸­å¿ƒï¼‰
let cursorPosition = { x: 0, y: 0 }; // å½“å‰æ‰‹æŒ‡å±å¹•åæ ‡
let isPinching = false; // æ˜¯å¦æ­£åœ¨æåˆ

// è®¾ç½®ç”»å¸ƒå°ºå¯¸
function resizeCanvas() {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
    config.width = window.innerWidth;
    config.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// MediaPipe Hands åˆå§‹åŒ–
const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

const camera = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 1280,
    height: 720
});
camera.start();

/**
 * è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ä¸¤ç‚¹è·ç¦»
 */
function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

/**
 * è¾…åŠ©å‡½æ•°ï¼šçº¿æ€§æ’å€¼ (å¹³æ»‘ç§»åŠ¨)
 */
function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
}

/**
 * ä¸»å¾ªç¯å›è°ƒ
 */
function onResults(results) {
    // 1. å‡†å¤‡ç”»å¸ƒ
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    // é•œåƒå¹¶ç»˜åˆ¶è§†é¢‘èƒŒæ™¯ï¼ˆå¯é€‰ï¼Œä¸ºäº†æ²‰æµ¸æ„Ÿè¿™é‡Œä¸ç”»è§†é¢‘åº•å›¾ï¼Œåªç”»é»‘èƒŒæ™¯+ç¬”è¿¹ï¼Œè‹¥æƒ³çœ‹è§†é¢‘æŠŠä¸‹é¢æ³¨é‡Šè§£å¼€ï¼‰
    // canvasCtx.translate(canvasElement.width, 0);
    // canvasCtx.scale(-1, 1);
    // canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
    // canvasCtx.restore(); 

    // 2. ç»˜åˆ¶å·²æœ‰çš„ç¬”è¿¹ (åº”ç”¨ç¼©æ”¾)
    drawPaths(canvasCtx);
    
    // 3. å¤„ç†æ¶ˆå¤±çš„ç²’å­ (é›ªèŠ±)
    updateAndDrawParticles(canvasCtx);

    // 4. æ‰‹åŠ¿é€»è¾‘å¤„ç†
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        processGestures(results.multiHandLandmarks, results.multiHandedness);
    } else {
        // æ²¡æœ‰æ‰‹çš„æ—¶å€™ï¼Œé‡ç½®ä¸€äº›çŠ¶æ€
        lastZoomDist = null;
        cursorPosition = null;
        statusBar.innerHTML = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
    }
    
    // ç»˜åˆ¶è™šæ‹Ÿå…‰æ ‡ï¼ˆå¦‚æœæœ‰ï¼‰
    if (cursorPosition) {
        drawCursor(canvasCtx, cursorPosition);
    }

    canvasCtx.restore();
}

/**
 * æ ¸å¿ƒæ‰‹åŠ¿å¤„ç†é€»è¾‘
 */
function processGestures(landmarksArray, handednessArray) {
    const numHands = landmarksArray.length;
    
    // ----------- åœºæ™¯ A: åŒæ‰‹æ“ä½œ (ç¼©æ”¾) -----------
    if (numHands === 2) {
        statusBar.innerHTML = "ğŸ‘ åŒæ‰‹æ£€æµ‹ï¼šé£ŸæŒ‡ç¼©æ”¾æ¨¡å¼";
        
        const hand1 = landmarksArray[0];
        const hand2 = landmarksArray[1];
        
        // è·å–ä¸¤ä¸ªé£ŸæŒ‡æŒ‡å°– (Index Tip is 8)
        const p1 = { x: hand1[8].x, y: hand1[8].y };
        const p2 = { x: hand2[8].x, y: hand2[8].y };
        
        const dist = distance(p1, p2);
        
        if (lastZoomDist) {
            const delta = dist - lastZoomDist;
            // ç®€å•çš„ç¼©æ”¾çµæ•åº¦å¤„ç†
            if (Math.abs(delta) > 0.01) {
                const zoomSpeed = 2; 
                scaleFactor += delta * zoomSpeed;
                scaleFactor = Math.max(0.1, Math.min(scaleFactor, 5)); // é™åˆ¶ç¼©æ”¾èŒƒå›´
            }
        }
        lastZoomDist = dist;
        
        // åŒæ‰‹æ¨¡å¼ä¸‹ä¸è¿›è¡Œç»˜å›¾æˆ–èœå•æ“ä½œ
        currentPath = []; 
        return; 
    } else {
        lastZoomDist = null;
    }

    // ----------- åœºæ™¯ B: å•æ‰‹æ“ä½œ -----------
    const landmarks = landmarksArray[0];
    
    // åæ ‡è½¬æ¢ (å½’ä¸€åŒ– -> åƒç´ , ä¸”éœ€æ°´å¹³ç¿»è½¬ x)
    const indexTip = landmarks[8];
    const thumbTip = landmarks[4];
    const middleTip = landmarks[12];
    
    // è®¡ç®—å±å¹•åæ ‡
    const screenX = (1 - indexTip.x) * config.width;
    const screenY = indexTip.y * config.height;
    
    // å¹³æ»‘å…‰æ ‡ä½ç½®
    if (!cursorPosition) cursorPosition = { x: screenX, y: screenY };
    cursorPosition.x = lerp(cursorPosition.x, screenX, 0.4);
    cursorPosition.y = lerp(cursorPosition.y, screenY, 0.4);

    // è®¡ç®—å…³é”®è·ç¦»
    const pinchDist = distance(indexTip, thumbTip); // æ‹‡æŒ‡-é£ŸæŒ‡
    const isPinchNow = pinchDist < 0.05; // æåˆé˜ˆå€¼

    // 1. æ£€æµ‹æ˜¯å¦å…¨æ‰‹å¼ å¼€ (ç”¨äºåˆ‡æ¢èœå•)
    // ç®€å•åˆ¤å®šï¼šäº”æŒ‡æŒ‡å°–éƒ½æ¯”è¾ƒèˆ’å±•ï¼Œæˆ–è€…ç®€åŒ–ä¸ºï¼šæŒ‡å°–ä¸æ‰‹è…•è·ç¦»è¾ƒè¿œ
    if (isHandOpen(landmarks)) {
        const now = Date.now();
        if (now - lastMenuToggleTime > 1000) { // 1ç§’å†·å´
            config.isMenuOpen = !config.isMenuOpen;
            toggleUI(config.isMenuOpen);
            lastMenuToggleTime = now;
        }
    }

    // 2. æ£€æµ‹ "V" å­—æ‰‹åŠ¿ (ç”¨äºæ¸…å±/é›ªèŠ±)
    // é£ŸæŒ‡ã€ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
    if (!config.isMenuOpen && isVictorySign(landmarks)) {
        triggerSnowEffect();
        statusBar.innerHTML = "âœŒï¸ æ¸…å±ç‰¹æ•ˆä¸­...";
        return;
    }

    // ----------- åœºæ™¯ C: èœå•äº¤äº’ -----------
    if (config.isMenuOpen) {
        statusBar.innerHTML = "ğŸ‘† èœå•æ¨¡å¼ï¼šé£ŸæŒ‡æŒ‡å¼•ï¼Œæåˆç¡®è®¤";
        handleUIInteraction(cursorPosition.x, cursorPosition.y, isPinchNow);
        currentPath = []; // èœå•æ¨¡å¼ä¸‹ä¸ç”»çº¿
        return;
    }

    // ----------- åœºæ™¯ D: ç»˜å›¾æ¨¡å¼ -----------
    statusBar.innerHTML = isPinchNow ? "âœï¸ æ­£åœ¨ä¹¦å†™..." : "âœ‹ æåˆé£ŸæŒ‡æ‹‡æŒ‡ä»¥ä¹¦å†™";

    if (isPinchNow) {
        // å¦‚æœä¹‹å‰æ²¡åœ¨ç”»ï¼Œå¼€å§‹æ–°çš„ä¸€ç¬”
        if (currentPath.length === 0) {
            // éœ€è¦åç®—ç¼©æ”¾åçš„åæ ‡å­˜å…¥è·¯å¾„
            // å±å¹•åæ ‡ = åŸå§‹åæ ‡ * scale + offset
            // åŸå§‹åæ ‡ = (å±å¹•åæ ‡ - offset) / scale
            // è¿™é‡Œç®€åŒ–ï¼šæˆ‘ä»¬åªå­˜å±å¹•ç»å¯¹åæ ‡ï¼Œæ¸²æŸ“æ—¶åº”ç”¨ scale
            // ä¸ºäº†è®©ç¼©æ”¾ä¹Ÿæ˜¯ä»¥ä¸­å¿ƒä¸ºåŸºå‡†ï¼Œè¿™é‡Œç›´æ¥å­˜åŸå§‹å€¼æ›´ç®€å•ï¼Œ
            // ä½†ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å­˜å‚¨â€œé€»è¾‘åæ ‡â€ã€‚
            // é€»è¾‘åæ ‡ = (CurrentPos - Center) / Scale + Center
            
            const logicPos = getLogicPos(cursorPosition);
            
            currentPath.push({
                x: logicPos.x,
                y: logicPos.y,
                color: config.tool === 'eraser' ? '#1e1e1e' : config.color, // ç®€å•æ©¡çš®æ“¦=ç”»èƒŒæ™¯è‰²
                size: config.lineWidth,
                tool: config.tool
            });
        } else {
             const logicPos = getLogicPos(cursorPosition);
             currentPath.push({
                x: logicPos.x,
                y: logicPos.y,
                color: config.tool === 'eraser' ? '#1e1e1e' : config.color,
                size: config.lineWidth,
                tool: config.tool
            });
        }
    } else {
        // æŠ¬èµ·æ‰‹æŒ‡ï¼Œç»“æŸå½“å‰ç¬”ç”»
        if (currentPath.length > 0) {
            drawingPaths.push([...currentPath]);
            currentPath = [];
        }
    }
}

/**
 * å·¥å…·ï¼šè·å–é€»è¾‘åæ ‡ï¼ˆæŠµæ¶ˆç¼©æ”¾å½±å“ï¼‰
 */
function getLogicPos(screenPos) {
    // ä»¥å±å¹•ä¸­å¿ƒä¸ºç¼©æ”¾åŸç‚¹
    const cx = config.width / 2;
    const cy = config.height / 2;
    return {
        x: (screenPos.x - cx) / scaleFactor + cx,
        y: (screenPos.y - cy) / scaleFactor + cy
    };
}

/**
 * æ£€æµ‹æ‰‹æŒæ˜¯å¦å®Œå…¨å¼ å¼€
 */
function isHandOpen(landmarks) {
    // ç®€å•çš„åˆ¤æ–­ï¼šæŒ‡å°–åˆ°æ‰‹è…•(0)çš„è·ç¦»æ˜¯å¦è¶³å¤Ÿå¤§ï¼Œæˆ–è€…åˆ¤æ–­æ‰‹æŒ‡å¼¯æ›²çŠ¶æ€
    // è¿™é‡Œä½¿ç”¨ç®€æ˜“åˆ¤æ–­ï¼šé£ŸæŒ‡(8)ã€ä¸­æŒ‡(12)ã€æ— åæŒ‡(16)ã€å°æŒ‡(20) çš„Yåæ ‡éƒ½å°äºå„è‡ªå…³èŠ‚
    // æ³¨æ„ï¼šYè½´å‘ä¸‹ä¸ºæ­£ã€‚æ‰‹æŒå‘ä¸Šæ—¶ï¼ŒæŒ‡å°–Yåº”è¯¥å°äºå…³èŠ‚Yã€‚
    // è¿™åœ¨ä¸åŒè§’åº¦æ¯”è¾ƒéš¾ï¼Œæ”¹ç”¨è·ç¦»åˆ¤å®šã€‚
    // åˆ¤å®šï¼šæŒ‡å°–åˆ°æŒå¿ƒ(0)è·ç¦» > é˜ˆå€¼ï¼Œä¸”æ‰‹æŒ‡æ˜¯åˆ†å¼€çš„
    
    // ç®€å•ç²—æš´æ³•ï¼šè®¡ç®—æ‰€æœ‰æ‰‹æŒ‡æŒ‡å°–(8,12,16,20)å’Œæ‹‡æŒ‡(4)åˆ°æ‰‹è…•(0)çš„è·ç¦»æ€»å’Œ
    // å¹¶æ£€æŸ¥æŒ‡å°–æ˜¯å¦äº’æ–¥
    // æ›´å¥½çš„æ–¹æ³•ï¼šåˆ©ç”¨ MediaPipe æä¾›çš„å‡ ä½•ç‰¹å¾ï¼Œè¿™é‡Œç®€åŒ–ä¸ºåˆ¤æ–­æ˜¯å¦æ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´
    
    const tips = [8, 12, 16, 20];
    const pips = [6, 10, 14, 18]; // è¿‘æŒ‡å…³èŠ‚
    
    let extendedCount = 0;
    
    // æ£€æŸ¥æ‹‡æŒ‡ (å¯¹æ¯” x è½´æˆ–è·ç¦»)
    if (distance(landmarks[4], landmarks[17]) > 0.15) extendedCount++; // æ‹‡æŒ‡å¼ å¼€

    for (let i = 0; i < 4; i++) {
        // å¦‚æœæŒ‡å°– åˆ° æ‰‹è…• çš„è·ç¦» > æŒ‡æ ¹ åˆ° æ‰‹è…• çš„è·ç¦» (è¯´æ˜ä¼¸ç›´)
        if (distance(landmarks[tips[i]], landmarks[0]) > distance(landmarks[pips[i]], landmarks[0]) * 1.3) {
            extendedCount++;
        }
    }
    
    return extendedCount === 5; // äº”æŒ‡å…¨å¼€
}

/**
 * æ£€æµ‹ V å­—æ‰‹åŠ¿ (ç”¨äºæ¸…å±)
 */
function isVictorySign(landmarks) {
    const tips = [8, 12, 16, 20];
    const pips = [6, 10, 14, 18];
    
    // é£ŸæŒ‡(8) ä¸­æŒ‡(12) ä¼¸ç›´
    const indexUp = distance(landmarks[8], landmarks[0]) > distance(landmarks[6], landmarks[0]) * 1.3;
    const middleUp = distance(landmarks[12], landmarks[0]) > distance(landmarks[10], landmarks[0]) * 1.3;
    
    // æ— åæŒ‡(16) å°æŒ‡(20) å¼¯æ›²
    const ringDown = distance(landmarks[16], landmarks[0]) < distance(landmarks[14], landmarks[0]) * 1.2;
    const pinkyDown = distance(landmarks[20], landmarks[0]) < distance(landmarks[18], landmarks[0]) * 1.2;
    
    // é£ŸæŒ‡ä¸­æŒ‡è¦æ˜¯åˆ†å¼€çš„
    const fingersSpread = distance(landmarks[8], landmarks[12]) > 0.05;

    return indexUp && middleUp && ringDown && pinkyDown && fingersSpread;
}

/**
 * ç»˜åˆ¶é€»è¾‘
 */
function drawPaths(ctx) {
    // è®¾å®šç¼©æ”¾ä¸­å¿ƒ
    const cx = config.width / 2;
    const cy = config.height / 2;
    
    ctx.save();
    // åº”ç”¨å˜æ¢çŸ©é˜µ
    ctx.translate(cx, cy);
    ctx.scale(scaleFactor, scaleFactor);
    ctx.translate(-cx, -cy);

    // ç»˜åˆ¶å†å²ç¬”è¿¹
    for (const path of drawingPaths) {
        if (path.length < 2) continue;
        drawSinglePath(ctx, path);
    }
    
    // ç»˜åˆ¶å½“å‰æ­£åœ¨ç”»çš„ç¬”è¿¹
    if (currentPath.length > 1) {
        drawSinglePath(ctx, currentPath);
    }
    
    ctx.restore();
}

function drawSinglePath(ctx, path) {
    ctx.beginPath();
    ctx.lineWidth = path[0].size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = path[0].color;
    
    if (path[0].tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out'; // çœŸå®çš„æ“¦é™¤é€æ˜
    } else {
        ctx.globalCompositeOperation = 'source-over';
    }

    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
    
    ctx.globalCompositeOperation = 'source-over'; // è¿˜åŸ
}

/**
 * ç»˜åˆ¶å…‰æ ‡
 */
function drawCursor(ctx, pos) {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 10, 0, 2 * Math.PI);
    ctx.fillStyle = config.tool === 'eraser' ? 'white' : config.color;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();
}

/**
 * UI äº¤äº’é€»è¾‘
 */
function toggleUI(isOpen) {
    if (isOpen) {
        uiPanel.classList.add('active');
        statusBar.innerHTML = "èœå•å·²æ‰“å¼€";
    } else {
        uiPanel.classList.remove('active');
        statusBar.innerHTML = "èœå•å·²å…³é—­";
    }
}

function handleUIInteraction(x, y, isClicking) {
    // è·å–æ‰€æœ‰ UI æŒ‰é’®
    const buttons = document.querySelectorAll('.btn');
    const panelRect = uiPanel.getBoundingClientRect();
    
    // æ£€æŸ¥å…‰æ ‡æ˜¯å¦åœ¨é¢æ¿èŒƒå›´å†…
    if (x >= panelRect.left && x <= panelRect.right && 
        y >= panelRect.top && y <= panelRect.bottom) {
        
        let hoveredBtn = null;

        buttons.forEach(btn => {
            const rect = btn.getBoundingClientRect();
            if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                hoveredBtn = btn;
                btn.classList.add('hovered');
            } else {
                btn.classList.remove('hovered');
            }
        });

        if (hoveredBtn && isClicking) {
            // æ‰§è¡Œç‚¹å‡»
            const type = hoveredBtn.dataset.type;
            const val = hoveredBtn.dataset.val;
            
            // æ›´æ–° UI çŠ¶æ€
            document.querySelectorAll(`.btn[data-type="${type}"]`).forEach(b => b.classList.remove('selected'));
            hoveredBtn.classList.add('selected');

            // æ›´æ–° Config
            if (type === 'tool') config.tool = val;
            if (type === 'color') config.color = val;
            if (type === 'size') config.lineWidth = parseInt(val);
        }
    } else {
        // æ¸…é™¤æ‚¬åœçŠ¶æ€
        buttons.forEach(btn => btn.classList.remove('hovered'));
    }
}

/**
 * é›ªèŠ±ç²’å­ç‰¹æ•ˆ
 */
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = Math.random() * 2 + 1;
        this.alpha = 1;
        this.size = Math.random() * 3 + 1;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= 0.01;
    }
    draw(ctx) {
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

function triggerSnowEffect() {
    // 1. å°†ç°æœ‰ç¬”è¿¹è½¬åŒ–ä¸ºç²’å­
    // ä¸ºäº†æ€§èƒ½ï¼Œä¸è½¬æ¢æ‰€æœ‰ç‚¹ï¼Œæ¯æ¡çº¿æŠ½æ ·è½¬åŒ–
    if (drawingPaths.length === 0 && currentPath.length === 0) return;

    const allPaths = [...drawingPaths, currentPath];
    
    // ç¼©æ”¾ä¸­å¿ƒ
    const cx = config.width / 2;
    const cy = config.height / 2;

    allPaths.forEach(path => {
        for (let i = 0; i < path.length; i += 3) { // æŠ½æ ·
            if (Math.random() > 0.5) continue; // éšæœºä¸¢å¼ƒ
            
            const pt = path[i];
            // è®¡ç®—å½“å‰è§†è§‰ä½ç½®
            const visualX = (pt.x - cx) * scaleFactor + cx;
            const visualY = (pt.y - cy) * scaleFactor + cy;
            
            particles.push(new Particle(visualX, visualY, pt.color || '#fff'));
        }
    });

    // 2. æ¸…ç©ºç¬”è¿¹
    drawingPaths = [];
    currentPath = [];
}

function updateAndDrawParticles(ctx) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx);
        if (p.alpha <= 0) {
            particles.splice(i, 1);
        }
    }
}

</script>
</body>
</html>
