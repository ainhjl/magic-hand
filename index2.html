<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 交互式粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* 摄像头预览窗口 - 放在右下角 */
        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            background: #000;
        }
        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 镜像翻转 */
        }

        /* 全屏按钮 */
        #fs-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: 0.3s;
            z-index: 100;
            font-size: 14px;
        }
        #fs-btn:hover { background: rgba(255, 255, 255, 0.3); }

        /* 加载提示 */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">正在启动摄像头与AI模型...</div>
    <button id="fs-btn">⛶ 全屏模式</button>
    
    <div id="video-container">
        <video id="input_video" playsinline></video>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 配置参数 ---
        const PARTICLE_COUNT = 20000;
        const PARTICLE_SIZE = 0.15;
        
        const params = {
            shape: 'Heart',
            color: '#ff4466',
            particleSize: 0.15,
            handInfluence: 0.0, // 0 = 闭合, 1 = 张开 (由 MediaPipe 驱动)
            autoRotate: true
        };

        // --- Three.js 初始化 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 30;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 粒子系统核心 ---
        // 存储两个位置：当前位置(positions) 和 目标位置(targetPositions)
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // 初始化位置（随机分布）
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: params.color,
            size: params.particleSize,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 形状生成算法 ---
        const shapes = {
            Heart: () => {
                const arr = [];
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // 爱心参数方程
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()); // 内部填充
                    // 稍作抖动使其更有体积感
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    const z = (Math.random() - 0.5) * 5; // 厚度
                    
                    const scale = 0.8 * r; 
                    arr.push(x * scale, y * scale, z);
                }
                return arr;
            },
            Flower: () => {
                const arr = [];
                // 斐波那契螺旋 (Phyllotaxis)
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const r = Math.sqrt(i) * 0.2;
                    const theta = i * goldenAngle;
                    const x = r * Math.cos(theta);
                    const y = (Math.random() - 0.5) * 5; // 花的高度/厚度
                    const z = r * Math.sin(theta);
                    arr.push(x, y, z);
                }
                return arr;
            },
            Saturn: () => {
                const arr = [];
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    if (i < PARTICLE_COUNT * 0.4) {
                        // 星球主体 (球体)
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const r = 8;
                        arr.push(
                            r * Math.sin(phi) * Math.cos(theta),
                            r * Math.sin(phi) * Math.sin(theta),
                            r * Math.cos(phi)
                        );
                    } else {
                        // 光环 (圆盘)
                        const angle = Math.random() * Math.PI * 2;
                        const r = 12 + Math.random() * 8; // 半径 12 到 20
                        arr.push(
                            r * Math.cos(angle),
                            (Math.random()-0.5) * 0.5, // 扁平
                            r * Math.sin(angle)
                        );
                    }
                }
                return arr;
            },
            Complex: () => {
                // 替代佛像：使用 TorusKnot (环面结) 采样
                const arr = [];
                const torusKnot = new THREE.TorusKnotGeometry(10, 3, 100, 16);
                const posAttribute = torusKnot.attributes.position;
                const count = posAttribute.count;
                
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    // 随机采样顶点
                    const index = Math.floor(Math.random() * count);
                    const x = posAttribute.getX(index);
                    const y = posAttribute.getY(index);
                    const z = posAttribute.getZ(index);
                    // 添加一点噪音扩散
                    arr.push(x + (Math.random() - 0.5), y + (Math.random() - 0.5), z + (Math.random() - 0.5));
                }
                return arr;
            },
            Fireworks: () => {
                // 炸开的球体
                const arr = [];
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 15 + Math.random() * 20; // 很大
                    arr.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                return arr;
            }
        };

        // 切换形状函数
        function updateShape(type) {
            const newPos = shapes[type]();
            // 更新目标数组
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targetPositions[i] = newPos[i] || 0;
            }
        }

        // 初始化第一个形状
        updateShape(params.shape);

        // --- UI 设置 (Lil-gui) ---
        const gui = new GUI({ title: "控制器" });
        gui.add(params, 'shape', Object.keys(shapes)).name('模型选择').onChange(updateShape);
        gui.addColor(params, 'color').name('粒子颜色').onChange(v => material.color.set(v));
        gui.add(params, 'particleSize', 0.05, 0.5).name('粒子大小').onChange(v => material.size = v);
        gui.add(params, 'autoRotate').name('自动旋转');

        // --- MediaPipe Hands 集成 ---
        const videoElement = document.getElementById('input_video');
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 逻辑：计算拇指指尖(4)和食指指尖(8)的距离，或者计算手掌张开程度
                // 这里我们计算手腕(0)到中指指尖(12)的距离作为手掌大小的近似
                // 或者更简单：食指(8)与拇指(4)的距离
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const wrist = landmarks[0];
                const middleTip = landmarks[12];

                // 计算两点间欧几里得距离
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 距离映射：通常 0.02 (闭合) 到 0.2 (张开)
                // 我们做一个平滑映射到 0~1
                let handState = (distance - 0.02) * 6; 
                handState = Math.max(0, Math.min(1, handState));

                // 使用 lerp 平滑数值，防止抖动
                params.handInfluence = THREE.MathUtils.lerp(params.handInfluence, handState, 0.1);
                
            } else {
                // 如果没有手，默认慢慢回到张开状态或保持
                params.handInfluence = THREE.MathUtils.lerp(params.handInfluence, 1.0, 0.05);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. 自动旋转
            if (params.autoRotate) {
                particles.rotation.y += delta * 0.1;
            }

            // 2. 粒子物理更新
            const posAttr = geometry.attributes.position;
            
            // 交互系数：如果手张开(1)，粒子趋向目标形状；如果手闭合(0)，粒子趋向中心(0,0,0)或紧缩
            const expansionFactor = 0.2 + (params.handInfluence * 0.8); // 最小缩放到0.2倍
            
            // 扩散/噪点系数：手张开时有些微漂浮感，闭合时紧凑
            const noiseAmp = params.handInfluence * 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                
                // 目标：原始目标位置 * 手势缩放系数
                // 如果想要"扩散"效果而非单纯缩放，可以在这里加随机偏移
                const tx = targetPositions[idx] * expansionFactor;
                const ty = targetPositions[idx+1] * expansionFactor;
                const tz = targetPositions[idx+2] * expansionFactor;

                // 当前位置
                const cx = posAttr.array[idx];
                const cy = posAttr.array[idx+1];
                const cz = posAttr.array[idx+2];

                // 缓动动画 (Lerp)
                posAttr.array[idx] += (tx - cx) * 0.1; // 0.1 是追踪速度
                posAttr.array[idx+1] += (ty - cy) * 0.1;
                posAttr.array[idx+2] += (tz - cz) * 0.1;

                // 添加微小的动态浮动（呼吸感）
                if (params.handInfluence > 0.5) {
                    posAttr.array[idx] += Math.sin(time * 2 + cx) * 0.02;
                    posAttr.array[idx+1] += Math.cos(time * 1.5 + cy) * 0.02;
                }
            }
            
            posAttr.needsUpdate = true;
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // --- 事件监听 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

    </script>
</body>
</html>
